# ğŸ–¼ï¸ å›¾ç‰‡ç³»ç»Ÿå®Œæ•´æŠ€æœ¯æ–‡æ¡£

## ğŸ“‹ ç³»ç»Ÿæ¦‚è¿°

æœ¬å›¾ç‰‡ç³»ç»ŸåŸºäºNext.jsæ„å»ºï¼Œé›†æˆKie.ai GPT-4o-image APIï¼Œæä¾›å›¾åƒä¸Šä¼ ã€å¤„ç†å’Œç”ŸæˆåŠŸèƒ½ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‰ç«¯å®¢æˆ·ç«¯     â”‚    â”‚   Next.js API    â”‚    â”‚   Kie.ai API    â”‚
â”‚   (React)       â”‚    â”‚    Routes        â”‚    â”‚   (å¤–éƒ¨æœåŠ¡)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â”‚ 1. ä¸Šä¼ å›¾ç‰‡           â”‚                       â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                       â”‚
         â”‚                       â”‚ 2. ä¸Šä¼ åˆ°ImgBB        â”‚
         â”‚                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
         â”‚                       â”‚                       â”‚ 3. è¿”å›URL
         â”‚                       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚                       â”‚ 4. ç”Ÿæˆå›¾åƒè¯·æ±‚       â”‚
         â”‚                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
         â”‚                       â”‚                       â”‚ 5. åˆ›å»ºä»»åŠ¡
         â”‚                       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚                       â”‚ 6. è½®è¯¢çŠ¶æ€           â”‚
         â”‚                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
         â”‚                       â”‚                       â”‚ 7. è¿”å›ç»“æœ
         â”‚                       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
         â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”‚
         â”‚ 8. æ˜¾ç¤ºç»“æœ           â”‚                       â”‚
```

## ğŸ”„ æ•°æ®æµè¯¦è§£

### 1. å›¾ç‰‡ä¸Šä¼ æµç¨‹

```mermaid
flowchart TD
    A[ç”¨æˆ·é€‰æ‹©å›¾ç‰‡] --> B[å‰ç«¯éªŒè¯]
    B --> C{éªŒè¯é€šè¿‡?}
    C -->|å¦| D[æ˜¾ç¤ºé”™è¯¯]
    C -->|æ˜¯| E[è°ƒç”¨ä¸Šä¼ API]
    E --> F[ä¸Šä¼ åˆ°ImgBB]
    F --> G{ä¸Šä¼ æˆåŠŸ?}
    G -->|å¦| H[è¿”å›é”™è¯¯]
    G -->|æ˜¯| I[è¿”å›å›¾ç‰‡URL]
    I --> J[æ›´æ–°å‰ç«¯çŠ¶æ€]
```

### 2. å›¾åƒç”Ÿæˆæµç¨‹

```mermaid
flowchart TD
    A[ç”¨æˆ·ç‚¹å‡»ç”Ÿæˆ] --> B[éªŒè¯å‚æ•°]
    B --> C{å‚æ•°å®Œæ•´?}
    C -->|å¦| D[æ˜¾ç¤ºé”™è¯¯]
    C -->|æ˜¯| E[è°ƒç”¨ç”ŸæˆAPI]
    E --> F[å‘é€åˆ°Kie.ai]
    F --> G{åˆ›å»ºä»»åŠ¡æˆåŠŸ?}
    G -->|å¦| H[è¿”å›é”™è¯¯]
    G -->|æ˜¯| I[è·å–ä»»åŠ¡ID]
    I --> J[å¼€å§‹è½®è¯¢]
    J --> K{ä»»åŠ¡å®Œæˆ?}
    K -->|å¦| L[ç­‰å¾…5ç§’]
    L --> J
    K -->|æ˜¯| M[è·å–ç»“æœURLs]
    M --> N[è¿”å›å‰ç«¯]
```

## ğŸ› ï¸ APIæ¥å£è¯¦è§£

### 1. å›¾ç‰‡ä¸Šä¼ API

**ç«¯ç‚¹**: `POST /api/upload-image`

**åŠŸèƒ½**: å°†ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡å­˜å‚¨åˆ°ImgBBå¹¶è¿”å›å¯è®¿é—®çš„URL

**è¯·æ±‚å‚æ•°**:
```typescript
interface UploadRequest {
  file: File;  // å›¾ç‰‡æ–‡ä»¶
}
```

**å“åº”æ ¼å¼**:
```typescript
interface UploadResponse {
  success: boolean;
  url: string;        // å›¾ç‰‡è®¿é—®URL
  fileName: string;   // æ–‡ä»¶å
  fileSize: number;   // æ–‡ä»¶å¤§å°
}
```

**ç¤ºä¾‹ä»£ç **:
```typescript
// å‰ç«¯ä¸Šä¼ ä»£ç 
const uploadImage = async (file: File) => {
  const formData = new FormData();
  formData.append('file', file);

  const response = await fetch('/api/upload-image', {
    method: 'POST',
    body: formData
  });

  if (!response.ok) {
    throw new Error('ä¸Šä¼ å¤±è´¥');
  }

  const data = await response.json();
  return data.url;
};

// ä½¿ç”¨ç¤ºä¾‹
const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];
  if (file) {
    try {
      const imageUrl = await uploadImage(file);
      setFileUrl(imageUrl);
      console.log('ä¸Šä¼ æˆåŠŸ:', imageUrl);
    } catch (error) {
      console.error('ä¸Šä¼ å¤±è´¥:', error);
    }
  }
};
```

### 2. å›¾åƒç”ŸæˆAPI

**ç«¯ç‚¹**: `POST /api/generate-image`

**åŠŸèƒ½**: è°ƒç”¨Kie.ai APIç”Ÿæˆå›¾åƒ

**è¯·æ±‚å‚æ•°**:
```typescript
interface GenerateRequest {
  fileUrl?: string;        // å‚è€ƒå›¾ç‰‡URL
  prompt: string;          // æç¤ºè¯
  enhancePrompt?: boolean; // æ˜¯å¦å¢å¼ºæç¤ºè¯
  size?: string;          // å›¾ç‰‡æ¯”ä¾‹: "1:1" | "3:2" | "2:3"
}
```

**å“åº”æ ¼å¼**:
```typescript
interface GenerateResponse {
  success: boolean;
  mode: 'external';
  url: string;              // ä¸»å›¾ç‰‡URL
  urls: string[];           // æ‰€æœ‰å›¾ç‰‡URLs
  taskId: string;           // ä»»åŠ¡ID
  generation_count: number; // ç”Ÿæˆæ•°é‡
  api_key_used: string;     // ä½¿ç”¨çš„APIå¯†é’¥
}
```

**ç¤ºä¾‹ä»£ç **:
```typescript
// å‰ç«¯ç”Ÿæˆä»£ç 
const generateImage = async (params: GenerateRequest) => {
  const response = await fetch('/api/generate-image', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(params)
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.error || 'ç”Ÿæˆå¤±è´¥');
  }

  const data = await response.json();
  return data;
};

// ä½¿ç”¨ç¤ºä¾‹
const handleGenerate = async () => {
  try {
    setIsGenerating(true);
    const result = await generateImage({
      fileUrl: selectedImageUrl,
      prompt: "å¯çˆ±çš„åŠ¨æ¼«å°‘å¥³ï¼Œç²‰è‰²å¤´å‘ï¼Œå¾®ç¬‘",
      enhancePrompt: true,
      size: "1:1"
    });
    
    setGeneratedImages(result.urls);
    console.log('ç”ŸæˆæˆåŠŸ:', result);
  } catch (error) {
    console.error('ç”Ÿæˆå¤±è´¥:', error);
  } finally {
    setIsGenerating(false);
  }
};
```

### 3. ä»»åŠ¡çŠ¶æ€æŸ¥è¯¢API

**ç«¯ç‚¹**: `GET /api/task-status`

**åŠŸèƒ½**: æŸ¥è¯¢å›¾åƒç”Ÿæˆä»»åŠ¡çŠ¶æ€

**è¯·æ±‚å‚æ•°**:
```typescript
interface StatusRequest {
  taskId: string;    // ä»»åŠ¡ID
  userId: string;    // ç”¨æˆ·ID
}
```

**å“åº”æ ¼å¼**:
```typescript
interface StatusResponse {
  code: number;
  data: {
    status: 'PENDING' | 'PROCESSING' | 'SUCCESS' | 'FAILED';
    response?: {
      resultUrls: string[];
    };
    errorMessage?: string;
  };
}
```

## ğŸ”§ è·¯ç”±å®ç°è¯¦è§£

### 1. å›¾ç‰‡ä¸Šä¼ è·¯ç”±

**æ–‡ä»¶**: `src/app/api/upload-image/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json(
        { error: 'æ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶' },
        { status: 400 }
      );
    }

    // éªŒè¯æ–‡ä»¶ç±»å‹
    if (!file.type.startsWith('image/')) {
      return NextResponse.json(
        { error: 'åªæ”¯æŒå›¾ç‰‡æ–‡ä»¶' },
        { status: 400 }
      );
    }

    // éªŒè¯æ–‡ä»¶å¤§å° (5MBé™åˆ¶)
    if (file.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { error: 'æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡5MB' },
        { status: 400 }
      );
    }

    // ä¸Šä¼ åˆ°ImgBB
    const imgbbApiKey = process.env.IMGBB_API_KEY;
    const uploadFormData = new FormData();
    uploadFormData.append('image', file);

    const imgbbResponse = await fetch(
      `https://api.imgbb.com/1/upload?key=${imgbbApiKey}`,
      {
        method: 'POST',
        body: uploadFormData
      }
    );

    if (!imgbbResponse.ok) {
      throw new Error('ImgBBä¸Šä¼ å¤±è´¥');
    }

    const imgbbData = await imgbbResponse.json();
    const imageUrl = imgbbData.data.url;

    return NextResponse.json({
      success: true,
      url: imageUrl,
      fileName: file.name,
      fileSize: file.size
    });

  } catch (error) {
    console.error('ä¸Šä¼ é”™è¯¯:', error);
    return NextResponse.json(
      { error: 'ä¸Šä¼ å¤±è´¥ï¼Œè¯·é‡è¯•' },
      { status: 500 }
    );
  }
}
```

### 2. å›¾åƒç”Ÿæˆè·¯ç”±

**æ–‡ä»¶**: `src/app/api/generate-image/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getApiKeyRotation } from '@/lib/api-key-rotation';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { fileUrl, prompt, enhancePrompt, size } = body;

    // éªŒè¯å¿…è¦å‚æ•°
    if (!prompt) {
      return NextResponse.json(
        { error: 'ç¼ºå°‘å¿…è¦å‚æ•°ï¼šprompt' },
        { status: 400 }
      );
    }

    // è·å–APIå¯†é’¥
    const rotation = getApiKeyRotation();
    const keyInfo = rotation.getNextKey();

    if (!keyInfo) {
      return NextResponse.json(
        { error: 'æ²¡æœ‰å¯ç”¨çš„APIå¯†é’¥' },
        { status: 500 }
      );
    }

    const { key: apiKey, userId: defaultUserId } = keyInfo;

    // æ„å»ºè¯·æ±‚æ•°æ®
    const requestData = {
      prompt: enhancePrompt ? `anime style, high quality, detailed, kawaii, ${prompt}` : prompt,
      model: 'gpt-4o-image',
      userId: defaultUserId,
      size: size || '1:1'
    };

    // æ·»åŠ å‚è€ƒå›¾ç‰‡
    if (fileUrl && !fileUrl.startsWith('data:')) {
      requestData.filesUrl = [fileUrl];
    }

    // è°ƒç”¨Kie.ai API
    const baseUrl = process.env.KIE_AI_BASE_URL || 'https://api.kie.ai';
    const generateEndpoint = `${baseUrl}/api/v1/gpt4o-image/generate`;

    const response = await fetch(generateEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'application/json'
      },
      body: JSON.stringify(requestData)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Kie.ai APIé”™è¯¯:', {
        status: response.status,
        response: errorText
      });
      
      return NextResponse.json({
        error: `APIè°ƒç”¨å¤±è´¥: ${response.status}`,
        details: errorText
      }, { status: response.status });
    }

    const generateData = await response.json();
    const taskId = generateData.taskId || generateData.data?.taskId;

    if (!taskId) {
      return NextResponse.json({
        error: 'æ— æ³•è·å–ä»»åŠ¡ID',
        response: generateData
      }, { status: 500 });
    }

    // è½®è¯¢ä»»åŠ¡çŠ¶æ€
    const result = await pollTaskStatus(taskId, defaultUserId, apiKey);
    
    // è®°å½•æˆåŠŸä½¿ç”¨
    rotation.recordSuccess(apiKey);

    return NextResponse.json(result);

  } catch (error) {
    console.error('ç”Ÿæˆé”™è¯¯:', error);
    return NextResponse.json({
      error: 'å›¾åƒç”Ÿæˆå¤±è´¥',
      details: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 });
  }
}

// è½®è¯¢ä»»åŠ¡çŠ¶æ€
async function pollTaskStatus(taskId: string, userId: string, apiKey: string) {
  const baseUrl = process.env.KIE_AI_BASE_URL || 'https://api.kie.ai';
  const recordEndpoint = `${baseUrl}/api/v1/gpt4o-image/record-info`;
  
  const maxAttempts = 60; // æœ€å¤š5åˆ†é’Ÿ
  let attempts = 0;

  while (attempts < maxAttempts) {
    await new Promise(resolve => setTimeout(resolve, 5000)); // ç­‰å¾…5ç§’
    attempts++;

    try {
      const statusUrl = `${recordEndpoint}?taskId=${taskId}&userId=${encodeURIComponent(userId)}`;
      const statusResponse = await fetch(statusUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'application/json'
        }
      });

      if (!statusResponse.ok) {
        if (attempts >= maxAttempts) {
          throw new Error(`çŠ¶æ€æŸ¥è¯¢å¤±è´¥: ${statusResponse.status}`);
        }
        continue;
      }

      const statusData = await statusResponse.json();
      const taskData = statusData.data || statusData;

      if (taskData.status === 'SUCCESS' || taskData.status === 'COMPLETED') {
        // æå–ç»“æœURLs
        let resultUrls = [];
        if (taskData.response?.resultUrls) {
          resultUrls = Array.isArray(taskData.response.resultUrls) 
            ? taskData.response.resultUrls 
            : [taskData.response.resultUrls];
        }

        if (resultUrls.length > 0) {
          return {
            success: true,
            mode: 'external',
            url: resultUrls[0],
            urls: resultUrls,
            taskId: taskId,
            generation_count: resultUrls.length
          };
        }
      } else if (taskData.status === 'FAILED' || taskData.status === 'ERROR') {
        throw new Error(`ä»»åŠ¡å¤±è´¥: ${taskData.errorMessage || 'æœªçŸ¥é”™è¯¯'}`);
      }

    } catch (error) {
      if (attempts >= maxAttempts) {
        throw error;
      }
      console.log('è½®è¯¢é”™è¯¯ï¼Œé‡è¯•ä¸­...');
    }
  }

  throw new Error('ä»»åŠ¡è¶…æ—¶');
}
```

## ğŸ“Š çŠ¶æ€ç®¡ç†

### 1. åº”ç”¨çŠ¶æ€Store

**æ–‡ä»¶**: `src/store/useAppStore.ts`

```typescript
import { create } from 'zustand';

export type AppState = 'initial' | 'uploading' | 'uploaded' | 'processing' | 'completed' | 'error';
export type ImageSize = '1:1' | '3:2' | '2:3';

interface AppStore {
  // çŠ¶æ€
  currentState: AppState;
  selectedSize: ImageSize;
  
  // å›¾ç‰‡æ•°æ®
  uploadedImage: string | null;
  generatedImages: string[];
  
  // åŠ è½½çŠ¶æ€
  isLoading: boolean;
  loadingProgress: number;
  loadingMessage: string;
  
  // é”™è¯¯çŠ¶æ€
  error: string | null;
  
  // Actions
  setCurrentState: (state: AppState) => void;
  setSelectedSize: (size: ImageSize) => void;
  setUploadedImage: (url: string | null) => void;
  setGeneratedImages: (urls: string[]) => void;
  setLoading: (loading: boolean, message?: string) => void;
  setLoadingProgress: (progress: number) => void;
  setError: (error: string | null) => void;
  resetApp: () => void;
}

export const useAppStore = create<AppStore>((set) => ({
  // åˆå§‹çŠ¶æ€
  currentState: 'initial',
  selectedSize: '1:1',
  uploadedImage: null,
  generatedImages: [],
  isLoading: false,
  loadingProgress: 0,
  loadingMessage: '',
  error: null,

  // Actions
  setCurrentState: (state) => set({ currentState: state }),
  setSelectedSize: (size) => set({ selectedSize: size }),
  setUploadedImage: (url) => set({ uploadedImage: url }),
  setGeneratedImages: (urls) => set({ generatedImages: urls }),
  setLoading: (loading, message = '') => set({ 
    isLoading: loading, 
    loadingMessage: message 
  }),
  setLoadingProgress: (progress) => set({ loadingProgress: progress }),
  setError: (error) => set({ error }),
  resetApp: () => set({
    currentState: 'initial',
    uploadedImage: null,
    generatedImages: [],
    isLoading: false,
    loadingProgress: 0,
    loadingMessage: '',
    error: null
  })
}));
```

### 2. ä½¿ç”¨ç¤ºä¾‹

```typescript
// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
import { useAppStore } from '@/store/useAppStore';

const MyComponent = () => {
  const {
    currentState,
    selectedSize,
    uploadedImage,
    generatedImages,
    isLoading,
    setCurrentState,
    setSelectedSize,
    setUploadedImage,
    setGeneratedImages,
    setLoading
  } = useAppStore();

  const handleImageUpload = async (file: File) => {
    setLoading(true, 'ä¸Šä¼ ä¸­...');
    setCurrentState('uploading');
    
    try {
      const imageUrl = await uploadImage(file);
      setUploadedImage(imageUrl);
      setCurrentState('uploaded');
    } catch (error) {
      setCurrentState('error');
    } finally {
      setLoading(false);
    }
  };

  const handleGenerate = async () => {
    setLoading(true, 'ç”Ÿæˆä¸­...');
    setCurrentState('processing');
    
    try {
      const result = await generateImage({
        fileUrl: uploadedImage,
        prompt: "å¯çˆ±çš„åŠ¨æ¼«å°‘å¥³",
        size: selectedSize
      });
      
      setGeneratedImages(result.urls);
      setCurrentState('completed');
    } catch (error) {
      setCurrentState('error');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      {/* ç»„ä»¶å†…å®¹ */}
    </div>
  );
};
```

## ğŸ” å®‰å…¨é…ç½®

### 1. ç¯å¢ƒå˜é‡

```bash
# .env.local
KIE_AI_API_KEY=your_kie_api_key
KIE_AI_USER_ID=your_user_id
KIE_AI_BASE_URL=https://api.kie.ai
IMGBB_API_KEY=your_imgbb_api_key
HTTP_PROXY=http://127.0.0.1:26001
HTTPS_PROXY=http://127.0.0.1:26001
```

### 2. APIå¯†é’¥è½®æ¢

```typescript
// src/lib/api-key-rotation.ts
export class ApiKeyRotation {
  private keys: string[];
  private currentIndex: number = 0;
  private successCount: Map<string, number> = new Map();
  private failureCount: Map<string, number> = new Map();

  constructor() {
    this.keys = process.env.KIE_AI_API_KEY?.split(',') || [];
  }

  getNextKey(): { key: string; userId: string } | null {
    if (this.keys.length === 0) return null;
    
    const key = this.keys[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.keys.length;
    
    return {
      key,
      userId: process.env.KIE_AI_USER_ID || ''
    };
  }

  recordSuccess(key: string) {
    const count = this.successCount.get(key) || 0;
    this.successCount.set(key, count + 1);
  }

  recordFailure(key: string) {
    const count = this.failureCount.get(key) || 0;
    this.failureCount.set(key, count + 1);
  }

  getStats() {
    return {
      successCount: Object.fromEntries(this.successCount),
      failureCount: Object.fromEntries(this.failureCount)
    };
  }
}

let rotationInstance: ApiKeyRotation | null = null;

export function getApiKeyRotation(): ApiKeyRotation {
  if (!rotationInstance) {
    rotationInstance = new ApiKeyRotation();
  }
  return rotationInstance;
}
```

## ğŸ“± å‰ç«¯ç»„ä»¶ç¤ºä¾‹

### 1. å›¾ç‰‡ä¸Šä¼ ç»„ä»¶

```typescript
// src/components/ImageUpload.tsx
import { useState, useRef } from 'react';
import { useAppStore } from '@/store/useAppStore';

export default function ImageUpload() {
  const { setUploadedImage, setLoading, setError } = useAppStore();
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const uploadImage = async (file: File) => {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch('/api/upload-image', {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'ä¸Šä¼ å¤±è´¥');
    }

    const data = await response.json();
    return data.url;
  };

  const handleFile = async (file: File) => {
    setLoading(true, 'ä¸Šä¼ ä¸­...');
    setError(null);

    try {
      const imageUrl = await uploadImage(file);
      setUploadedImage(imageUrl);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'ä¸Šä¼ å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(false);

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      handleFile(files[0]);
    }
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setDragActive(true);
  };

  const handleDragLeave = () => {
    setDragActive(false);
  };

  return (
    <div
      className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
        dragActive 
          ? 'border-pink-400 bg-pink-50' 
          : 'border-gray-300 hover:border-pink-300'
      }`}
      onDrop={handleDrop}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        onChange={(e) => {
          const file = e.target.files?.[0];
          if (file) handleFile(file);
        }}
        className="hidden"
      />
      
      <div className="space-y-4">
        <div className="text-4xl">ğŸ“¸</div>
        <div className="text-lg font-medium text-gray-700">
          æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œæˆ–ç‚¹å‡»ä¸Šä¼ 
        </div>
        <button
          onClick={() => fileInputRef.current?.click()}
          className="px-4 py-2 bg-pink-500 text-white rounded-lg hover:bg-pink-600 transition-colors"
        >
          é€‰æ‹©æ–‡ä»¶
        </button>
      </div>
    </div>
  );
}
```

### 2. å›¾åƒç”Ÿæˆç»„ä»¶

```typescript
// src/components/ImageGenerator.tsx
import { useState } from 'react';
import { useAppStore } from '@/store/useAppStore';

export default function ImageGenerator() {
  const { 
    uploadedImage, 
    selectedSize, 
    setSelectedSize, 
    setGeneratedImages, 
    setLoading, 
    setError 
  } = useAppStore();
  
  const [prompt, setPrompt] = useState('');
  const [enhancePrompt, setEnhancePrompt] = useState(false);

  const generateImage = async () => {
    if (!uploadedImage || !prompt.trim()) {
      setError('è¯·å…ˆä¸Šä¼ å›¾ç‰‡å¹¶è¾“å…¥æç¤ºè¯');
      return;
    }

    setLoading(true, 'ç”Ÿæˆä¸­...');
    setError(null);

    try {
      const response = await fetch('/api/generate-image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          fileUrl: uploadedImage,
          prompt: prompt.trim(),
          enhancePrompt,
          size: selectedSize
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'ç”Ÿæˆå¤±è´¥');
      }

      const data = await response.json();
      setGeneratedImages(data.urls);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'ç”Ÿæˆå¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* å°ºå¯¸é€‰æ‹© */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          é€‰æ‹©å°ºå¯¸
        </label>
        <div className="grid grid-cols-3 gap-3">
          {(['1:1', '3:2', '2:3'] as const).map((size) => (
            <button
              key={size}
              onClick={() => setSelectedSize(size)}
              className={`p-3 rounded-lg border-2 transition-colors ${
                selectedSize === size
                  ? 'border-pink-500 bg-pink-50 text-pink-700'
                  : 'border-gray-300 hover:border-pink-300'
              }`}
            >
              {size}
            </button>
          ))}
        </div>
      </div>

      {/* æç¤ºè¯è¾“å…¥ */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          æç¤ºè¯
        </label>
        <textarea
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="æè¿°æ‚¨æƒ³è¦çš„å›¾åƒæ•ˆæœ..."
          className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-transparent"
          rows={4}
        />
      </div>

      {/* å¢å¼ºé€‰é¡¹ */}
      <div className="flex items-center">
        <input
          type="checkbox"
          id="enhancePrompt"
          checked={enhancePrompt}
          onChange={(e) => setEnhancePrompt(e.target.checked)}
          className="rounded border-gray-300 text-pink-500 focus:ring-pink-500"
        />
        <label htmlFor="enhancePrompt" className="ml-2 text-sm text-gray-700">
          å¢å¼ºæç¤ºè¯æ•ˆæœ
        </label>
      </div>

      {/* ç”ŸæˆæŒ‰é’® */}
      <button
        onClick={generateImage}
        disabled={!uploadedImage || !prompt.trim()}
        className="w-full py-3 px-4 bg-pink-500 text-white rounded-lg hover:bg-pink-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
      >
        ç”Ÿæˆå›¾åƒ
      </button>
    </div>
  );
}
```

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### 1. APIæµ‹è¯•

```typescript
// tests/api.test.ts
import { describe, it, expect } from 'vitest';

describe('å›¾ç‰‡ä¸Šä¼ API', () => {
  it('åº”è¯¥æˆåŠŸä¸Šä¼ å›¾ç‰‡', async () => {
    const formData = new FormData();
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
    formData.append('file', file);

    const response = await fetch('/api/upload-image', {
      method: 'POST',
      body: formData
    });

    expect(response.ok).toBe(true);
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.url).toBeDefined();
  });

  it('åº”è¯¥æ‹’ç»éå›¾ç‰‡æ–‡ä»¶', async () => {
    const formData = new FormData();
    const file = new File(['test'], 'test.txt', { type: 'text/plain' });
    formData.append('file', file);

    const response = await fetch('/api/upload-image', {
      method: 'POST',
      body: formData
    });

    expect(response.ok).toBe(false);
    const data = await response.json();
    expect(data.error).toContain('åªæ”¯æŒå›¾ç‰‡æ–‡ä»¶');
  });
});

describe('å›¾åƒç”ŸæˆAPI', () => {
  it('åº”è¯¥æˆåŠŸç”Ÿæˆå›¾åƒ', async () => {
    const response = await fetch('/api/generate-image', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        fileUrl: 'https://example.com/image.jpg',
        prompt: 'å¯çˆ±çš„åŠ¨æ¼«å°‘å¥³',
        size: '1:1'
      })
    });

    expect(response.ok).toBe(true);
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.urls).toBeDefined();
    expect(data.urls.length).toBeGreaterThan(0);
  });

  it('åº”è¯¥éªŒè¯å¿…è¦å‚æ•°', async () => {
    const response = await fetch('/api/generate-image', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        fileUrl: 'https://example.com/image.jpg',
        size: '1:1'
        // ç¼ºå°‘ prompt
      })
    });

    expect(response.ok).toBe(false);
    const data = await response.json();
    expect(data.error).toContain('ç¼ºå°‘å¿…è¦å‚æ•°');
  });
});
```

### 2. ç»„ä»¶æµ‹è¯•

```typescript
// tests/components.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import ImageUpload from '../src/components/ImageUpload';

describe('ImageUploadç»„ä»¶', () => {
  it('åº”è¯¥æ˜¾ç¤ºä¸Šä¼ ç•Œé¢', () => {
    render(<ImageUpload />);
    expect(screen.getByText('æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œæˆ–ç‚¹å‡»ä¸Šä¼ ')).toBeInTheDocument();
    expect(screen.getByText('é€‰æ‹©æ–‡ä»¶')).toBeInTheDocument();
  });

  it('åº”è¯¥å¤„ç†æ–‡ä»¶é€‰æ‹©', async () => {
    const mockUpload = vi.fn().mockResolvedValue('https://example.com/image.jpg');
    global.fetch = mockUpload;

    render(<ImageUpload />);
    
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
    const input = screen.getByRole('button', { name: 'é€‰æ‹©æ–‡ä»¶' });
    
    fireEvent.click(input);
    
    await waitFor(() => {
      expect(mockUpload).toHaveBeenCalled();
    });
  });
});
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. å›¾ç‰‡å‹ç¼©

```typescript
// src/lib/image-compression.ts
export async function compressImage(file: File, maxWidth: number = 1024): Promise<File> {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d')!;
    const img = new Image();

    img.onload = () => {
      const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
      canvas.width = img.width * ratio;
      canvas.height = img.height * ratio;

      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      canvas.toBlob((blob) => {
        if (blob) {
          const compressedFile = new File([blob], file.name, {
            type: file.type,
            lastModified: Date.now()
          });
          resolve(compressedFile);
        }
      }, file.type, 0.8);
    };

    img.src = URL.createObjectURL(file);
  });
}
```

### 2. ç¼“å­˜ç­–ç•¥

```typescript
// src/lib/cache.ts
export class ImageCache {
  private cache = new Map<string, { url: string; timestamp: number }>();
  private maxAge = 24 * 60 * 60 * 1000; // 24å°æ—¶

  set(key: string, url: string) {
    this.cache.set(key, { url, timestamp: Date.now() });
    this.cleanup();
  }

  get(key: string): string | null {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > this.maxAge) {
      this.cache.delete(key);
      return null;
    }

    return item.url;
  }

  private cleanup() {
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > this.maxAge) {
        this.cache.delete(key);
      }
    }
  }
}

export const imageCache = new ImageCache();
```

## ğŸ” ç›‘æ§å’Œæ—¥å¿—

### 1. é”™è¯¯ç›‘æ§

```typescript
// src/lib/error-monitoring.ts
export class ErrorMonitor {
  private errors: Array<{
    timestamp: number;
    error: string;
    context: any;
  }> = [];

  logError(error: string, context?: any) {
    this.errors.push({
      timestamp: Date.now(),
      error,
      context
    });

    // å‘é€åˆ°ç›‘æ§æœåŠ¡
    this.sendToMonitoringService(error, context);
  }

  private async sendToMonitoringService(error: string, context?: any) {
    try {
      await fetch('/api/log-error', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ error, context, timestamp: Date.now() })
      });
    } catch (e) {
      console.error('Failed to send error to monitoring service:', e);
    }
  }

  getErrors() {
    return this.errors;
  }

  clearErrors() {
    this.errors = [];
  }
}

export const errorMonitor = new ErrorMonitor();
```

### 2. æ€§èƒ½ç›‘æ§

```typescript
// src/lib/performance-monitoring.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  startTimer(name: string): () => void {
    const start = performance.now();
    return () => this.endTimer(name, start);
  }

  private endTimer(name: string, start: number) {
    const duration = performance.now() - start;
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(duration);
  }

  getAverageTime(name: string): number {
    const times = this.metrics.get(name);
    if (!times || times.length === 0) return 0;
    return times.reduce((a, b) => a + b, 0) / times.length;
  }

  getMetrics() {
    const result: Record<string, number> = {};
    for (const [name, times] of this.metrics.entries()) {
      result[name] = this.getAverageTime(name);
    }
    return result;
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

## ğŸ“ æ€»ç»“

è¿™ä¸ªå›¾ç‰‡ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„å›¾åƒä¸Šä¼ ã€å¤„ç†å’Œç”ŸæˆåŠŸèƒ½ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **å®Œæ•´çš„APIæ¥å£**: æ”¯æŒå›¾ç‰‡ä¸Šä¼ ã€å›¾åƒç”Ÿæˆã€çŠ¶æ€æŸ¥è¯¢
2. **å¥å£®çš„é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯æ•è·å’Œç”¨æˆ·æç¤º
3. **çŠ¶æ€ç®¡ç†**: ä½¿ç”¨Zustandè¿›è¡Œå…¨å±€çŠ¶æ€ç®¡ç†
4. **æ€§èƒ½ä¼˜åŒ–**: å›¾ç‰‡å‹ç¼©ã€ç¼“å­˜ç­–ç•¥ã€æ€§èƒ½ç›‘æ§
5. **å®‰å…¨é…ç½®**: APIå¯†é’¥è½®æ¢ã€ç¯å¢ƒå˜é‡ç®¡ç†
6. **æµ‹è¯•è¦†ç›–**: å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
7. **ç›‘æ§ç³»ç»Ÿ**: é”™è¯¯ç›‘æ§å’Œæ€§èƒ½ç›‘æ§

ç³»ç»Ÿè®¾è®¡è€ƒè™‘äº†å¯æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§å’Œç”¨æˆ·ä½“éªŒï¼Œå¯ä»¥ä½œä¸ºç”Ÿäº§ç¯å¢ƒçš„åŸºç¡€æ¶æ„ã€‚ 