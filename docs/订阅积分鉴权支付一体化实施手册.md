### 2kawaii 订阅/支付/鉴权/积分 一体化实施手册（Clerk + Google、Creem、Railway Postgres）

本文档整合并细化全部产品/技术需求：
- Google 登录（Clerk）
- 订阅支付（Creem）
- Railway Postgres 存储（Prisma）
- 每日免费积分 30 点（每天重置为 30，不累计）
- 会员积分（到期制，随订阅周期发放，到期自动失效）
- 每次生成消耗 10 点积分（不够则禁止使用）
- 账户页（订阅记录、积分余额、使用记录、限制提示）
- 定价页（Pricing）展示套餐与购买
- Workspace 编辑区的登录/积分不足锁定（PC/移动端）
- 风控与幂等（防未登录/刷登录/并发重复扣费）


---

### 一、需求清单（汇总）

- 必须登录才能使用 Workspace 编辑区；未登录直接锁定。
- 登录用户：
  - 每日免费积分为 30 点；每天重置为 30（不累计）。
  - 会员积分按订阅发放，随周期到期自动失效。
  - 每次生成扣 10 点：优先用免费积分，不足再用会员积分。
  - 积分不足则锁定编辑区；引导购买或等次日重置。
- 定价套餐（10 分/次）：
  - ライト Light：$5.9 / ¥915 → 500 会员积分 → 50 次/月
  - スタンダード Standard：$12.9 / ¥1,999 → 1500 会员积分 → 150 次/月
  - 3ヶ月パック 3-Month Pack：$29.9 / ¥4,635 → 5000 会员积分 → 500 次/3 个月
  - 年間パック Annual Pack：$99.9 / ¥15,485 → 25000 会员积分 → 2,500 次/年
- 账户页展示：订阅记录、积分余额（免费/会员）、会员到期时间、最近使用记录、限制提示与 CTA。
- 风控：
  - 登录发放采用“懒刷新重置为 30”，避免反复登录刷积分。
  - 服务端强制鉴权与扣费校验；`X-Idempotency-Key` 防重。
  - 失败与并发处理、简单速率限制（可选）。


---

### 二、目标架构与选型

- 推荐部署：Railway 全站（Next.js standalone + Prisma 直连 Railway Postgres）。
  - 服务端路由统一迁移/新增至 `src/app/api/*`。
  - 现有 Cloudflare Pages Functions 可逐步迁移或保留与 R2 相关路径。


### 二点五、集成实施步骤（2kawaii + Clerk + Creem + Railway）

1) 项目准备
- 设置 Railway 项目与 Postgres 数据库，拿到 `DATABASE_URL`。
- 配置环境变量：Clerk、Creem、DATABASE_URL、`RAILWAY=true`、（可选）R2/KIE 变量。
- 安装依赖：`npm i @prisma/client @clerk/nextjs`，`npm i -D prisma`。

2) 数据库/Prisma
- 运行：`npx prisma init` → 写入本文档的 Prisma 模型 → `npx prisma migrate dev` → `npx prisma generate`。
- 新建 `src/server/prisma.ts` 单例导出。

3) 鉴权（Clerk + Google）
- Clerk 控制台开启 Google OAuth，配置回调域名（Railway 生产域/本地 dev）。
- `src/app/layout.tsx` 包裹 `ClerkProvider`，Header 增加 `SignInButton/UserButton`。
- 所有受保护 API 使用 `auth()` 校验，未登录返回 401。

4) Creem 支付/订阅
- 在 Creem 控制台创建对应套餐商品，记录 `product.id`，填入 `PRODUCT_CREDITS` 映射（见第七节）。
- 新增 `POST /api/checkout/create`：服务端用 `CREEM_API_KEY` 调 Creem 创建 Checkout，`metadata` 写入 `clerkUserId`/内部用户ID。
- 新增 `POST /api/webhooks/creem`：校验 `x-creem-signature`，处理 `subscription.paid/active/trialing` 发放积分，`canceled/expired` 停止发放；记录 `WebhookEvent` 与 `Payment`。

5) 积分/使用逻辑
- 新建 `src/server/credits.ts`：实现“每日懒刷新至30”、“每次扣10（先免费后会员）”、“CreditLedger/UsageLog 记账”、“grantMembershipCredits”。
- 在 `/api/account`、`/api/credits/spend`、Webhook 和其他用户相关接口里调用 `lazyRefreshDailyFree`。

6) API 路由（Next app router）
- `GET /api/account`：返回用户、余额、订阅/支付/使用记录。
- `POST /api/credits/spend`：Header 携带 `X-Idempotency-Key`；不足返回 402；成功写台账与使用日志。
- `POST /api/checkout/create`：返回 `checkoutUrl` 并跳转。
- `POST /api/webhooks/creem`：订阅同步与积分发放。
- 生成流的 `/api/generate-image`：复用 `X-Idempotency-Key` 做幂等绑定（与 spend 对应）。

7) 前端改造
- Workspace：加载 `GET /api/account`，计算 `isLocked = !signedIn || total<10`；统一禁用上传/模板/尺寸/生成（PC/移动端），加遮罩与 CTA（登录/定价）。
- 生成按钮：先 `POST /api/credits/spend`（带 `X-Idempotency-Key`），成功后再发起生成并复用该 key。

8) 页面
- 新建 `/pricing`：展示四个套餐卡片；登录后“购买”调用 `/api/checkout/create`。
- 新建 `/account`：展示余额、到期、订阅、支付、使用记录与 CTA。

9) 部署与联调
- Railway 设置所有变量 → 构建 `npm install && npx prisma generate && npx next build`。
- 打开定价购买一次 → 观察 Webhook 入站 → 数据库出现 Subscription/Payment/CreditLedger → `/account` 余额更新。
- Workspace 验证：未登录锁定、登录当日 30、扣 10、积分不足锁定、次日重置恢复。


---

### 三、环境变量清单（Railway Variables）

- Clerk（Google 登录）
  - `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`
  - `CLERK_SECRET_KEY`
- Creem（订阅/支付）
  - `CREEM_WEBHOOK_SECRET`（Webhook 签名验证）
  - `CREEM_API_KEY`（服务端创建 checkout）
- 数据库
  - `DATABASE_URL`（Railway Postgres 连接串）
- Next/运行
  - `RAILWAY=true`
- 现有生成/R2（如继续使用）
  - `KIE_AI_*`、`CLOUDFLARE_R2_*` 等


---

### 四、数据库与 Prisma 模型

以 Railway Postgres 为主，使用 Prisma 管理模型与迁移。

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                        String   @id @default(cuid())
  clerkUserId               String   @unique
  email                     String?  @unique
  name                      String?
  imageUrl                  String?
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  // 每日免费积分（每天重置为 30）
  freeDailyCreditsRemaining Int      @default(30)
  freeDailyLastReset        DateTime @default(now())

  // 会员积分快照（真实结算以 CreditLedger 为准）
  membershipCreditsBalance  Int      @default(0)
  membershipCreditsExpiresAt DateTime?

  activePlan                String?
  subscriptionId            String?

  shares          Share[]
  subscriptions   Subscription[]
  creditLogs      CreditLedger[]
  usageLogs       UsageLog[]
}

model Share {
  id            String   @id @default(cuid())
  userId        String?
  user          User?    @relation(fields: [userId], references: [id])
  generatedUrl  String
  originalUrl   String?
  prompt        String   @default("")
  style         String   @default("default")
  isR2Stored    Boolean  @default(false)
  isTextToImage Boolean  @default(false)
  width         Int?     @default(800)
  height        Int?     @default(800)
  createdAt     DateTime @default(now())
  @@index([createdAt])
  @@index([userId])
}

model Subscription {
  id                 String   @id @default(cuid())
  userId             String
  user               User     @relation(fields: [userId], references: [id])
  provider           String   @default("creem")
  providerCustomerId String
  providerProductId  String?
  providerSubId      String   @unique
  status             String
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  @@index([userId])
  @@index([providerSubId])
}

model Payment {
  id             String   @id @default(cuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id])
  provider       String   @default("creem")
  providerTranId String   @unique
  amount         Int
  currency       String
  status         String   // paid | refunded | chargeback
  description    String?
  subscriptionId String?
  createdAt      DateTime @default(now())
  @@index([userId])
  @@index([subscriptionId])
}

// 积分台账（发放/消耗全记录，正=发放，负=消耗）
model CreditLedger {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  kind      String   // free_daily | subscription | purchase | spend | adjust
  amount    Int
  meta      Json?
  expiresAt DateTime?
  createdAt DateTime @default(now())
  @@index([userId, createdAt])
  @@index([userId, expiresAt])
}

// 使用日志：每次生成的扣费来源与状态
model UsageLog {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  shareId   String?
  cost      Int
  fromFree  Int
  fromMember Int
  status    String   // success | failed | refunded
  createdAt DateTime @default(now())
  meta      Json?
  @@index([userId, createdAt])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  eventId     String   @unique
  eventType   String
  payload     Json
  processed   Boolean  @default(false)
  createdAt   DateTime @default(now())
  processedAt DateTime?
  note        String?
  @@index([eventType, createdAt])
}
```

初始化：
```bash
npm i -D prisma
npm i @prisma/client
npx prisma init
# 配置 .env 的 DATABASE_URL
npx prisma migrate dev --name init_credits_subs
npx prisma generate
```


---

### 五、业务规则与积分模型

- 每日免费积分：每天首次访问受保护接口时“懒刷新”为 30（不累计）。
- 会员积分：按订阅周期发放固定额度，到期（`current_period_end_date`）后视为 0；续费发新额度。
- 扣费顺序：默认先扣每日免费，再扣会员（可通过常量切换）。
- 每次生成成本：10 分。


---

### 六、鉴权（Clerk + Google）

1) 安装：`npm i @clerk/nextjs`

2) 在 `src/app/layout.tsx` 包裹 `ClerkProvider`，并在 Header 等处使用 `SignedIn/SignedOut/SignInButton/UserButton`。

3) 服务端 API 使用 `auth()` 校验，所有生成/扣费/账户/结账/Webhook 等均需鉴权或签名验证。


---

### 七、Creem 订阅与 Webhook

- 套餐商品与积分映射（示例）：

```ts
// 根据 Creem 的 product.id 映射到套餐积分
const PRODUCT_CREDITS: Record<string, number> = {
  // 'prod_light': 500,
  // 'prod_std': 1500,
  // 'prod_3m': 5000,
  // 'prod_annual': 25000,
}
```

- Webhook 事件：重点处理 `subscription.paid` / `subscription.active|trialing` 发放积分、`subscription.canceled|expired` 停止发放；`refund.created` / `dispute.created` 记录状态。
- 签名验证：使用 `CREEM_WEBHOOK_SECRET` 对原始 Body 做 HMAC-SHA256（以 Creem 实际规则为准）。

发放逻辑（简要）：
1) 解析事件，拿到 `subscription.id`、`customer.id`、`product.id`、`current_period_end_date`。
2) 通过 `metadata.internal_customer_id` 或自建映射找到我方 `user.id`。
3) `grantMembershipCredits(userId, credits, expiresAt)`；更新 Subscription 与 User 快照。


---

### 八、服务端公共工具（片段）

`src/server/prisma.ts`
```ts
import { PrismaClient } from '@prisma/client'
declare global { var prisma: PrismaClient | undefined }
export const prisma = global.prisma || new PrismaClient()
if (process.env.NODE_ENV !== 'production') global.prisma = prisma
```

`src/server/credits.ts`（关键逻辑，懒刷新/扣费/发放）
```ts
const DAILY_FREE = 30
export const COST_PER_USE = 10

export async function lazyRefreshDailyFree(userId: string) { /* 判断日期变更 → 重置为30并记账 */ }
export async function getBalances(userId: string) { /* 返回 freeDaily、member、costPerUse */ }
export async function spendForGeneration(userId: string, opts?: { idempotencyKey?: string }) { /* 先free后member，Ledger+UsageLog写入 */ }
export async function grantMembershipCredits(userId: string, amount: number, expiresAt: Date, meta?: any) { /* 发放并更新快照 */ }
```


---

### 九、API 设计与参数

- GET `/api/account`
  - 鉴权：必须登录
  - 返回：
    - `user`: { id, clerkUserId, activePlan, subscriptionId }
    - `balances`: { freeDaily, member, costPerUse }
    - `subscriptions[]`（最近 N 条）
    - `payments[]`（最近 N 条）
    - `usage[]`（最近 N 条）

- POST `/api/credits/spend`
  - 鉴权：必须登录
  - Header：`X-Idempotency-Key`
  - 返回：
    - 200 `{ ok: true, freeAfter, memberAfter }`
    - 402 `{ ok: false, reason: 'INSUFFICIENT_CREDITS', free, member, need }`

- POST `/api/checkout/create`
  - 鉴权：必须登录
  - Body：`{ productId, planId }`
  - 返回：`{ ok: true, checkoutUrl }`

- POST `/api/webhooks/creem`
  - 签名头：`x-creem-signature`
  - Body：事件原始 JSON
  - 行为：记录 `WebhookEvent`、更新 Subscription、发放/失效会员积分

- 生成流相关（约定）：
  - 生成前必须先成功调用 `/api/credits/spend`，并在 `/api/generate-image` 请求头里携带相同的 `X-Idempotency-Key`；服务端对该 key 做幂等校验。


---

### 十、前端改造：Workspace 锁定（PC/移动端）

核心逻辑：
- 加载账户信息：`GET /api/account` → `balances`。
- `total = freeDaily + member`，`cost = 10` → `isLocked = !signedIn || total < cost`。
- 将以下控件统一 `disabled={isLocked}`：
  - 文件选择/拖拽上传、模式切换、模板选择、尺寸按钮、生成按钮。
- 在编辑区上加遮罩：
  - 未登录：提示“登录即每日 30 分”，提供登录按钮。
  - 已登录但不足：提示“积分不足，去定价/等待次日重置”，提供跳转 `/pricing`。
- 生成按钮点击：先 `POST /api/credits/spend`（携带 `X-Idempotency-Key`），成功后再调用 `/api/generate-image` 并复用该 key。
- 账户信息获取失败时：默认锁定，避免“信息缺失”导致无限使用。

UI 文案（建议）：
- 未登录遮罩：`ログインすると毎日30ポイントが付与されます。まずはログインしてください。`
- 积分不足遮罩：`ポイント不足：プランを購入するか、明日30ポイントのリセットをお待ちください。10ポイント/回、毎日30ポイント無料。`


---

### 十一、Pricing 与 Account 页面

- Pricing：`/pricing`
  - 套餐卡片（价格、积分、可生成次数、描述）
  - 登录后“购买” → `POST /api/checkout/create` → 跳转 Creem Checkout
  - 未登录 → 弹登录

- Account：`/account`
  - 余额卡片：免费剩余、会员剩余、到期时间、每次扣费规则
  - 订阅列表、支付记录、最近使用记录
  - CTA：升级套餐、前往 Workspace 生成


---

### 十二、风控与幂等

- 未登录不可用：服务端强制鉴权，前端锁定仅为体验增强。
- 登录刷 30 分：不在“登录事件”直接加分；改为“按天懒刷新至 30”，同日不重复发放。
- 并发重复扣费：`X-Idempotency-Key` + 事务写 `CreditLedger`，必要时在 `meta.idempotencyKey` 上做唯一约束（或应用层校验重复）。
- 刷接口：可对 `/api/credits/spend`、`/api/generate-image` 做简单限流（如每分钟 N 次）。
- 会员过期：每次扣费前检查 `membershipCreditsExpiresAt > now`，否则按 0 计算。
- 失败退款（可选）：生成失败时记 `UsageLog.status='failed'`；是否自动返还 10 分视产品策略决定（建议简化为不返，以降低复杂度）。


---

### 十三、部署与迁移

1) Railway 新增 Postgres，获取 `DATABASE_URL`。
2) 配置 Railway Variables：Clerk、Creem、DATABASE_URL、RAILWAY 等。
3) `npm install && npx prisma generate && npx next build`。
4) 启动：Railway 使用 Next standalone 启动脚本（项目已在 `next.config.ts` 里支持 `RAILWAY=true`）。
5) Cloudflare Functions 的 R2/生成相关可平滑迁移到 Next API 或保留（前端统一改造调用路径）。


---

### 十四、开发联调清单（QA）

- 未登录访问 Workspace：编辑区被遮罩、按钮禁用；登录后恢复。
- 登录用户首次访问当天：余额显示免费 30；同日刷新不再重复。
- 积分不足：Workspace 锁定、提示与跳转 Pricing。
- Pricing 购买 → Creem → Webhook → DB 更新订阅并发放会员积分 → Account 显示余额/到期。
- 生成流：`/api/credits/spend` 成功 → `/api/generate-image` 成功 → UsageLog 记录扣费与来源。
- 会员到期：到期后 member=0（读取逻辑自动判定），待续费发新额度。


---

### 十五、改进方案（不足与改进落实）

本节将“建议补强点”落成可执行的模型/接口/前端与运维策略。

#### 1) 积分幂等与一致性

- 模型增强：为 `CreditLedger` 增加请求幂等键，避免并发重复扣费。

```prisma
model CreditLedger {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  kind            String   // free_daily | subscription | purchase | spend | adjust | refund
  amount          Int
  meta            Json?
  expiresAt       DateTime?
  idempotencyKey  String?  @db.VarChar(64)
  createdAt       DateTime @default(now())

  @@index([userId, createdAt])
  @@index([userId, expiresAt])
  @@unique([userId, idempotencyKey])
}
```

- 扣费接口：`POST /api/credits/spend` 必须带 `X-Idempotency-Key`；服务端：
  - 若相同 `userId+key` 已存在 `spend` 记录则直接返回成功（重放容忍）。
  - 可设置 TTL（例如 15 分钟），超过视为过期不可复用（在应用层校验 `createdAt`）。
  - 生成完成后将此次 `shareId` 回填到对应的 `UsageLog`（通过相同 key 关联）。

示例（片段）：
```ts
// spendForGeneration(userId, { idempotencyKey })
// 1) 查询 ledger 是否已存在相同 key
// 2) 若不存在 → 事务扣费（user.free/member 更新、ledger-10、usageLog 创建）
// 3) 若存在 → 直接返回 allowed=true（代表上次已扣费）
```

#### 2) 会员积分快照与过期同步

- 读取时将过期会员积分视为 0（已实现），同时建议在请求入口同步清零，减少 UI 偏差：

```ts
async function syncExpireMembership(user: User) {
  const now = new Date()
  if (user.membershipCreditsExpiresAt && user.membershipCreditsExpiresAt <= now && user.membershipCreditsBalance > 0) {
    await prisma.user.update({
      where: { id: user.id },
      data: { membershipCreditsBalance: 0 }
    })
  }
}
// 在 /api/account、/api/credits/spend、Webhook 等入口优先调用
```

#### 3) 日重置边界与时区

- 若面向日本用户，建议按 JST（Asia/Tokyo）0 点判断“是否跨日”：

```ts
function isDifferentDayJST(a: Date, b: Date) {
  const toJstYmd = (d: Date) => new Intl.DateTimeFormat('en-CA', { timeZone: 'Asia/Tokyo', year: 'numeric', month: '2-digit', day: '2-digit' }).format(d)
  return toJstYmd(a) !== toJstYmd(b)
}

export async function lazyRefreshDailyFree(userId: string) {
  const user = await prisma.user.findUnique({ where: { id: userId } })
  if (!user) return
  if (isDifferentDayJST(user.freeDailyLastReset, new Date())) {
    await prisma.$transaction([
      prisma.user.update({ where: { id: userId }, data: { freeDailyCreditsRemaining: 30, freeDailyLastReset: new Date() } }),
      prisma.creditLedger.create({ data: { userId, kind: 'free_daily', amount: 30, meta: { tz: 'JST' } } })
    ])
  }
}
```

#### 4) 风控与限流（可选增强）

- 为 `/api/credits/spend`、`/api/generate-image` 增加每用户每分钟 N 次的限流：
  - 简易方案：进程内内存计数 Map；
  - 分布式方案：Redis 计数器（推荐线上）。

```ts
// 简易示意（进程内）
const bucket = new Map<string, { cnt: number; ts: number }>()
function hitLimit(userId: string, limit = 20) {
  const now = Date.now(), k = userId
  const rec = bucket.get(k)
  if (!rec || now - rec.ts > 60_000) { bucket.set(k, { cnt: 1, ts: now }); return false }
  if (rec.cnt >= limit) return true
  rec.cnt++; return false
}
```

#### 5) 失败与退款策略

- 简化策略：生成失败不自动返还（推荐，降低复杂度）。
- 完整策略：生成失败自动补偿，需使用相同 `idempotencyKey` 幂等：

```ts
// 在生成失败路径
await prisma.$transaction([
  prisma.creditLedger.create({ data: { userId, kind: 'refund', amount: +10, meta: { reason: 'generate_failed', idempotencyKey } } }),
  prisma.usageLog.updateMany({ where: { userId, meta: { path: ['idempotencyKey'], equals: idempotencyKey } }, data: { status: 'refunded' } })
])
```

#### 6) Workspace 全面锁定范围

- 统一以 `isLocked = !signedIn || (freeDaily + member) < 10` 控制：
  - 文件选择/拖拽上传、模式切换（簡単/図→図/文→図）、模板卡片、尺寸按钮、主生成按钮、移动端底栏按钮与输入框（含 prompt）。
- 给 `SizeButton` 与模板卡片增加 `disabled` 透传与样式灰显，阻止点击事件：

```tsx
// SizeButton 增加 disabled
const SizeButton = ({ size, isSelected, onClick, isMobile = false, disabled = false }: { /* ... */ disabled?: boolean }) => (
  <button disabled={disabled} onClick={onClick} className={disabled ? 'opacity-50 cursor-not-allowed ...' : '...'}>...</button>
)
```

#### 7) 定价与商品映射

- 在 Creem 控制台记录四个套餐的 `product.id`，并在后端维护：

```ts
const PRODUCT_CREDITS: Record<string, number> = {
  // 'prod_light': 500,
  // 'prod_std': 1500,
  // 'prod_3m': 5000,
  // 'prod_annual': 25000
}
```

#### 8) Webhook 安全与幂等

- 验证 `x-creem-signature` 按官方算法（以 Creem 文档为准）。
- `WebhookEvent.eventId` 唯一，已处理则直接 200 返回，避免重复发放；
- 订阅事件与支付事件均采用 upsert 幂等写入。

```ts
// 已有：WebhookEvent(eventId) 唯一
const existed = await prisma.webhookEvent.findUnique({ where: { eventId } })
if (existed?.processed) return NextResponse.json({ ok: true })
```

#### 9) 页面与体验

- Pricing：购买成功回到 `/account`，提示“已发放会员积分，当前余额 …”。
- Workspace：在页面聚焦或生成结束后轻量刷新 `/api/account`，同步余额，减少“点击后才发现不足”的体验落差。

#### 10) 分享逻辑统一

- 按你现有决策，移除“自动分享”，改为用户手动点击“分享”按钮时再创建；
- 降低多余写入 KV/DB 与副作用，分享数据与积分/订阅系统解耦。

---

### 附录 A：套餐映射参考

| 套餐 | 价格（USD） | 价格（日元） | 积分 | 次数（10 分/次） | 备注 |
| --- | --- | --- | --- | --- | --- |
| ライト Light | $5.9 | ¥915 | 500 | 50 | 低门槛体验 |
| スタンダード Standard | $12.9 | ¥1,999 | 1500 | 150 | 主力档 |
| 3ヶ月パック 3-Month Pack | $29.9 | ¥4,635 | 5000 | 500 | 省心型 |
| 年間パック Annual Pack | $99.9 | ¥15,485 | 25000 | 2500 | 重度/商用 |

在 Creem 控制台记录各套餐的 `product.id` 并填入 `PRODUCT_CREDITS` 映射表。


---

### 附录 B：接口示例交互（简）

1) 获取账户：
```http
GET /api/account
Authorization: Bearer <Clerk JWT>
```

2) 预扣费：
```http
POST /api/credits/spend
Authorization: Bearer <Clerk JWT>
X-Idempotency-Key: <uuid>
```

3) 创建结账：
```http
POST /api/checkout/create
Authorization: Bearer <Clerk JWT>
Content-Type: application/json

{ "productId": "prod_std", "planId": "std" }
```

4) Webhook（Creem → 我方）：
```http
POST /api/webhooks/creem
X-Creem-Signature: <hmac>
Content-Type: application/json

{ "id": "evt_xxx", "eventType": "subscription.paid", "object": { /* ... */ } }
```


---

### 结语

本手册覆盖了订阅/支付/鉴权/积分的完整落地方案与风控逻辑。按本文档实施后，可满足：
- 登录要求与编辑区锁定
- 每日免费 30 点与每次 10 点成本
- 会员积分到期制与订阅发放
- 账户与定价页面的产品化展示
- 服务端幂等与防滥用

如需我将上述接口/页面/工具的代码骨架直接落地到仓库，请明确 Creem 的商品 ID 映射与部署目标（是否完全迁移至 Railway），我将一次性提交对应 edits。


